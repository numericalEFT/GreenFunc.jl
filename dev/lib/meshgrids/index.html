<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MeshGrids · GreenFunc.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://numericaleft.github.io/GreenFunc.jl/lib/meshgrids/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GreenFunc.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../greenfunc/">GreenFunc</a></li><li><a class="tocitem" href="../mesharrays/">MeshArrays</a></li><li class="is-active"><a class="tocitem" href>MeshGrids</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>MeshGrids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MeshGrids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/numericaleft/GreenFunc.jl/blob/master/docs/src/lib/meshgrids.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MeshGrids"><a class="docs-heading-anchor" href="#MeshGrids">MeshGrids</a><a id="MeshGrids-1"></a><a class="docs-heading-anchor-permalink" href="#MeshGrids" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.DLRFreq" href="#GreenFunc.MeshGrids.DLRFreq"><code>GreenFunc.MeshGrids.DLRFreq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function DLRFreq(β, isFermi::Bool=false;
    dtype=Float64,
    rtol=1e-12,
    Euv=1000 / β,
    sym=:none,
    rebuild=false,
    dlr::Union{DLRGrid,Nothing}=nothing
)</code></pre><p>Create a <code>DLRFreq</code> struct from parameters.</p><p><strong>Arguments</strong></p><ul><li><code>β</code>: inverse temperature.</li><li><code>isFermi</code>: the statistics for particles is fermionic or not. False by default.</li><li><code>dtype</code>: type of <code>β</code> and <code>Euv</code>.</li><li><code>rtol</code>: tolerance absolute error. By default, <code>rtol</code> = 1e-12.</li><li><code>Euv</code>: the UV energy scale of the spectral density. By default, <code>Euv = 1000 / β</code>.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>rebuild</code>: if no dlr is input, set false to load DLRGrid from the file; set true to recalculate the DLRGrid on the fly. By default, <code>rebuild = false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/dlrfreq.jl#L29-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.DLRFreq" href="#GreenFunc.MeshGrids.DLRFreq"><code>GreenFunc.MeshGrids.DLRFreq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DLRFreq{T&lt;:Real} &lt;: TemporalGrid{Int}</code></pre><p>Discrete-Lehmann-representation grid for Green&#39;s functions. </p><p><strong>Parameters</strong></p><ul><li><code>T</code>: type of the <code>grid</code> point, <code>β</code> and <code>Euv</code>.</li></ul><p><strong>Members</strong></p><ul><li><code>dlr</code>: built-in DLR grid.</li><li><code>grid</code>: 1D grid of time axis, with locate, volume, and AbstractArray interface implemented. It should be grid of Int for ImFreq, and DLRGrid for DLRFreq.</li><li><code>β</code>: inverse temperature.</li><li><code>Euv</code>:  the UV energy scale of the spectral density.</li><li><code>rtol</code>: tolerance absolute error.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>isFermi</code>: the statistics for particles. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/dlrfreq.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.DLRFreq-Tuple{Lehmann.DLRGrid}" href="#GreenFunc.MeshGrids.DLRFreq-Tuple{Lehmann.DLRGrid}"><code>GreenFunc.MeshGrids.DLRFreq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function DLRFreq(dlr::DLRGrid)</code></pre><p>Create a <code>DLRFreq</code> struct from <code>DLRGrid</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dlr</code>: 1D DLR grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/dlrfreq.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImFreq" href="#GreenFunc.MeshGrids.ImFreq"><code>GreenFunc.MeshGrids.ImFreq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function ImFreq(β, isFermi::Bool=false;
    dtype=Float64,
    Euv=1000 / β,
    rtol=1e-12,
    symmetry=:none,
    grid::Union{AbstractGrid,AbstractVector,Nothing}=nothing
)</code></pre><p>Create a <code>ImFreq</code> struct from parameters.</p><p><strong>Arguments</strong></p><ul><li><code>β</code>: inverse temperature.</li><li><code>isFermi</code>: the statistics for particles is fermionic or not. False by default.</li><li><code>dtype</code>: type of <code>β</code> and <code>Euv</code>. By default, <code>dtype = Float64</code>.</li><li><code>Euv</code>: the UV energy scale of the spectral density. By default, <code>Euv = 1000 / β</code>.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>grid</code>: 1D Matsubara-frequency integer-valued grid as a AbstractVector or CompositeGrids.AbstractGrid. By default, a optimized grid built in DLR is used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImFreq" href="#GreenFunc.MeshGrids.ImFreq"><code>GreenFunc.MeshGrids.ImFreq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ImFreq{T, G, R} &lt;: TemporalGrid{Int}</code></pre><p>Imaginary-frequency grid for Green&#39;s functions. </p><p><strong>Parameters</strong></p><ul><li><code>T&lt;:Real</code>: type of the <code>grid</code> point, <code>β</code> and <code>Euv</code>.</li><li><code>G&lt;:AbstractGrid{T}</code>: type of 1D grid with <code>T</code> as the grid point type.</li><li><code>R</code>: type of the representation.</li><li>REV: access the grid in reverse order or not.</li></ul><p><strong>Members</strong></p><ul><li><code>grid</code>: 1D grid of time axis, with locate, volume, and AbstractArray interface implemented. Always in ascend order It should be grid of Int for ImFreq, and DLRGrid for DLRFreq.</li><li><code>β</code>: inverse temperature.</li><li><code>Euv</code>:  the UV energy scale of the spectral density.</li><li><code>isFermi</code>: the statistics for particles is fermionic or not.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>rtol</code>: relative tolerance</li><li><code>representation</code>: the representation of the Green&#39;s function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImFreq-Tuple{Lehmann.DLRGrid}" href="#GreenFunc.MeshGrids.ImFreq-Tuple{Lehmann.DLRGrid}"><code>GreenFunc.MeshGrids.ImFreq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ImFreq(dlr::DLRGrid; dtype=Float64, grid::Union{AbstractGrid,AbstractVector}=SimpleG.Arbitrary{Int}(dlr.n))</code></pre><p>Construct <code>ImFreq</code> from a <code>DLRGrid</code>, with a given <code>grid</code>. By default, <code>grid</code> is the Matsubara-frequency points from <code>DLRGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImTime" href="#GreenFunc.MeshGrids.ImTime"><code>GreenFunc.MeshGrids.ImTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function ImTime(β, isFermi::Bool=false;
    dtype=Float64,
    rtol=1e-12,
    Euv=1000 / β,
    symmetry=:none,
    grid::Union{AbstractGrid,AbstractVector,Nothing}=nothing
)</code></pre><p>Create a <code>ImTime</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>β</code>: inverse temperature.</li><li><code>isFermi</code>: the statistics for particles is fermionic or not. False by default.</li><li><code>dtype</code>: type of the <code>grid</code> point. By default, <code>dtype = Float64</code>.</li><li><code>Euv</code>: the UV energy scale of the spectral density. By default, <code>Euv = 1000 / β</code>.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>grid</code>: 1D time grid as a AbstractVector or CompositeGrids.AbstractGrid. By default, a optimized grid built in DLR is used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imtime.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImTime" href="#GreenFunc.MeshGrids.ImTime"><code>GreenFunc.MeshGrids.ImTime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ImTime{T, G, R} &lt;: TemporalGrid{T}</code></pre><p>Time grid for Green&#39;s functions.</p><p><strong>Parameters</strong></p><ul><li><code>T&lt;:Real</code>: type of the <code>grid</code> point, <code>β</code> and <code>Euv</code>.</li><li><code>G&lt;:AbstractGrid{T}</code>: type of 1D grid with <code>T</code> as the grid point type.</li><li><code>R</code>: type of the representation.</li><li>REV: access the grid in reverse order or not.</li></ul><p><strong>Members</strong></p><ul><li><code>grid</code>: 1D grid of time axis, with locate, volume, and AbstractArray interface implemented. Always in ascend order. It should be grid of Int for ImFreq, and DLRGrid for DLRFreq.</li><li><code>β</code>: inverse temperature.</li><li><code>Euv</code>:  the UV energy scale of the spectral density.</li><li><code>isFermi</code>: the statistics for particles is fermionic or not.</li><li><code>symmetry</code>: <code>:ph</code> for particle-hole symmetric, <code>:pha</code> for particle-hole symmetry, and <code>:none</code> for no symmetry. By default, <code>sym = :none</code>.</li><li><code>rtol</code>: relative tolerance</li><li><code>representation</code>: the representation of the Green&#39;s function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imtime.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.ImTime-Tuple{Lehmann.DLRGrid}" href="#GreenFunc.MeshGrids.ImTime-Tuple{Lehmann.DLRGrid}"><code>GreenFunc.MeshGrids.ImTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ImTime(dlr::DLRGrid; dtype=Float64, grid::Union{AbstractGrid,AbstractVector}=SimpleG.Arbitrary{dtype}(dlr.τ))</code></pre><p>Construct <code>ImTime</code> from a <code>DLRGrid</code>, with a given <code>grid</code>. By default, <code>grid</code> is the imaginary-time grid points from <code>DLRGrid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imtime.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.MeshProduct" href="#GreenFunc.MeshGrids.MeshProduct"><code>GreenFunc.MeshGrids.MeshProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The cartesian Mesh product:</p><p>#Parameters:</p><ul><li>&#39;MT&#39;: Type of meshes </li><li>&#39;N&#39; : Number of meshes</li></ul><p>#Members:</p><ul><li>&#39;meshes&#39; : The list of Meshes in the MeshProduct</li><li>&#39;dims&#39; : A tuple of the length of the mesh factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{T}, Tuple{TemporalGrid{T, false}, Any}} where T" href="#Base.floor-Union{Tuple{T}, Tuple{TemporalGrid{T, false}, Any}} where T"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.floor(tg::TemporalGrid{T,false}, pos) where {T} = floor(tg.grid, pos) #TODO: how to implement?
Base.floor(tg::TemporalGrid{T,true}, pos) where {T} = length(tg) - floor(tg.grid, pos) #TODO: how to implement?</code></pre><p>If the grid is in ascend order, then floor returns the largest index that the grid point is smaller than pos. If the grid is in descend order, then floor returns the largest index that the grid point is larger than pos.</p><p>In both cases, the returned index is in the range [1, length(tg)-1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/common.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{R}, Tuple{G}, Tuple{T}, Tuple{ImFreq{T, G, R, false}, Int64}} where {T, G, R}" href="#Base.getindex-Union{Tuple{R}, Tuple{G}, Tuple{T}, Tuple{ImFreq{T, G, R, false}, Int64}} where {T, G, R}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(g::ImFreq{T, G, R, REV}, I::Int)</code></pre><p>Equivalent to <code>g[I]</code>, get the <strong>real-valued</strong> Matsubara frequency of the Ith point in the grid.  For fermion, return (2g[I]+1)π/β, for boson, return 2g[I]*π/β.</p><p>If REV = true, then index in the reversed order, namely I will be replaced with <code>length(g) - I + 1</code>.</p><p>If you need the <strong>integer-valued</strong> frequency, use <code>g.grid[I]</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L111-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{MeshProduct}" href="#Base.length-Tuple{MeshProduct}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.length(obj::MeshProduct)</code></pre><p>Return the number of grids of the MeshProduct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, DLRFreq}" href="#Base.show-Tuple{IO, DLRFreq}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, tg::DLRFreq)</code></pre><p>Write a text representation of the DLR grid <code>tg</code> to the output stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/dlrfreq.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, ImFreq}" href="#Base.show-Tuple{IO, ImFreq}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, tg::ImFreq)</code></pre><p>Write a text representation of the Imaginary-frequency grid <code>tg</code> to the output stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, ImTime}" href="#Base.show-Tuple{IO, ImTime}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io::IO, tg::ImTime)</code></pre><p>Write a text representation of the Imaginary-time grid <code>tg</code> to the output stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imtime.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MeshProduct}" href="#Base.show-Tuple{IO, MeshProduct}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.show(io::IO, obj::MeshProduct)</code></pre><p>Print the MeshProduct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L146-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{MeshProduct, Int64}" href="#Base.size-Tuple{MeshProduct, Int64}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.size(obj::MeshProduct, I::Int)</code></pre><p>Return the length of the specifict Ith mesh factor of the MeshProduct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{MeshProduct}" href="#Base.size-Tuple{MeshProduct}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.size(obj::MeshProduct, I::Int)</code></pre><p>Return the length of the specifict Ith mesh factor of the MeshProduct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.index_to_linear-Union{Tuple{N}, Tuple{MT}, Tuple{MeshProduct{MT, N}, Vararg{Any}}} where {MT, N}" href="#GreenFunc.MeshGrids.index_to_linear-Union{Tuple{N}, Tuple{MT}, Tuple{MeshProduct{MT, N}, Vararg{Any}}} where {MT, N}"><code>GreenFunc.MeshGrids.index_to_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function index_to_linear(obj::MeshProduct, index...)</code></pre><p>Convert a tuple of the indexes of each mesh to a single linear index of the MeshProduct.</p><p><strong>Argument:</strong></p><ul><li>&#39;obj&#39;: The MeshProduct object</li><li>&#39;index...&#39;: N indexes of the mesh factor, where N is the number of mesh factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.linear_to_index-Union{Tuple{N}, Tuple{MT}, Tuple{MeshProduct{MT, N}, Int64}} where {MT, N}" href="#GreenFunc.MeshGrids.linear_to_index-Union{Tuple{N}, Tuple{MT}, Tuple{MeshProduct{MT, N}, Int64}} where {MT, N}"><code>GreenFunc.MeshGrids.linear_to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function linear_to_index(obj::MeshProduct, I::Int)</code></pre><p>Convert the single linear index of the MeshProduct to a tuple of indexes of each mesh. </p><p><strong>Argument:</strong></p><ul><li>&#39;obj&#39;: The MeshProduct object</li><li>&#39;I&#39;: The linear index of the MeshProduct </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/MeshProduct.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GreenFunc.MeshGrids.locate-Tuple{ImFreq, Int64}" href="#GreenFunc.MeshGrids.locate-Tuple{ImFreq, Int64}"><code>GreenFunc.MeshGrids.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">locate(tg::ImFreq, n::Int)
locate(tg::ImFreq, ωn)</code></pre><p>Find the location in <code>tg.grid</code> for the Matsubara frequency <code>ωn</code> or the integer <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/GreenFunc.jl/blob/8e08d6a54e17f9e0acdd3f5b822dead882aab043/src/meshgrids/imfreq.jl#L132-L137">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mesharrays/">« MeshArrays</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 24 April 2023 04:20">Monday 24 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
